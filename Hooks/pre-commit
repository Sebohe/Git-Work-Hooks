#!/bin/sh

#xx.yy.zz.ACD
# xx = major number
# yy = revision number
# zz = commit number




gitStatusP=$(git status --porcelain)

#This first for replaces all of the _ in a file version.
for x in $gitStatusP; do
	#echo $x
	#echo $x | sed 's/^.*v//' | awk -F_ 'NR==1{print NF}'

	if [[ $(echo $x | sed 's/^.*v//' | awk -F_ 'NR==1{print NF}') -eq 3 ]]
	then
		#echo $x
		#fileVersionWithUnderscores=$(echo $x | sed 's/^.*v//' )
		fileVersionWithDots=$(echo $x | sed 's/^.*v//' | sed 's/_/./g' )
		#echo $fileVersionWithDots
		correctFileName=$( echo $x | cut -d v -f 1)
		correctFileName=$(echo $correctFileName"v"$fileVersionWithDots)
		#echo "correctFileName"
		git mv $x $correctFileName
		#echo ""
	fi
done


gitStatusP=$(git status --porcelain)
for x in $gitStatusP; do
	if [[ $(echo $x | awk -F. 'NR==1{print NF}') -eq 4  ]]; then
		stagedFileName="not initiated"
		conditionOnStagedFile=$(git status --porcelain | grep "$x" | awk '{print $1}')

		if [[ $conditionOnStagedFile == "M" ]]
		then
			stagedFileName=$(git status --porcelain | grep "$x" | awk '{print $2}')

		elif [[ $conditionOnStagedFile == "R" ]]
		then
			#this skips the 4th column iteration of $x so as to avoid
			#running the hook twice on the staged file and previous commit filename

			if [[ $(echo $gitStatusP | awk '{print $4}') != $(echo $x) ]];then

				stagedFileName=$(git status --porcelain | grep "$x" | awk '{print $4}')
				lastCommitFileName=$(git status --porcelain | grep "$x" | awk '{print $2}')
			fi
		else
			stagedFileName="outside of tracking condition:"
		fi
		##############################################################
		#This "if" determines if the standard FS is only of one. So only one space.
		#our file naming does not use spaces in its name
		if [[ $(echo $stagedFileName | awk 'NR==1{print NF}' ) -eq 1 ]]; then

			currentCommitNumber=$(echo $stagedFileName | awk 'BEGIN {FS=".";} {print $3; }')
			newCommitNumber=$(echo $currentCommitNumber | xargs -I {} expr {} + 1)
			newFileName=$stagedFileName

			if [[ $conditionOnStagedFile == "M" ]]; then
			newFileName=$(echo $stagedFileName |
							awk  'BEGIN {FS=OFS=".";} {$3='$newCommitNumber';} {print;}')
			fi
			#Runs this section of the code if the file has been renamed
			if [[ $conditionOnStagedFile == "R" ]]
			then
				lastMajorNumber=$(echo $lastCommitFileName |
							awk  'BEGIN {FS=".";} {print $1;}' | sed 's/^.*v//')
				lastRevisionNumber=$(echo $lastCommitFileName |
								awk  'BEGIN {FS=".";} {print $2;}')

				newMajorNumber=$(echo $stagedFileName |
								awk  'BEGIN {FS=".";} {print $1;}' | sed 's/^.*v//')
				newRevisionNumber=$(echo $stagedFileName |
								awk  'BEGIN {FS=".";} {print $2;}')

				if [[ $lastMajorNumber != $newMajorNumber ]]
				then
					newFileName=$(echo $stagedFileName |
								awk  'BEGIN {FS=OFS=".";} {$3=0;} {print;}')
					newFileName=$(echo $newFileName |
								awk  'BEGIN {FS=OFS=".";} {$2=0;} {print;}')

				elif [[ ( $lastRevisionNumber != $newRevisionNumber ) && ( $lastMajorNumber == $newMajorNumber ) ]]
				then
					newFileName=$(echo $stagedFileName |
								awk  'BEGIN {FS=OFS=".";} {$3="0";} {print;}')
				fi

			fi
			if [ $stagedFileName != $newFileName ]; then
				git mv $stagedFileName $newFileName
				echo "Hook executed for" $newFileName
			fi
		fi
	fi

done
#
